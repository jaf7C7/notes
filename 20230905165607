GNU Readline cheat sheet
========================


Commands For Moving
-------------------

`beginning-of-line` (`C-a`)
> Move to the start of the current line.

`end-of-line` (`C-e`)
> Move to the end of the line.

`forward-char` (`C-f`)
> Move forward a character.

`backward-char` (`C-b`)
> Move back a character.

`forward-word` (`M-f`)
> Move forward to the end of the next word. Words are composed of letters and digits.

`backward-word` (`M-b`)
> Move back to the start of the current or previous word. Words are composed of letters
> and digits.


Commands For Manipulating The History
-------------------------------------

`accept-line` (Newline or Return)
> Accept the line regardless of where the cursor is. If this line is non-empty, it may
> be added to the history list for future recall with add_history(). If this line is
> a modified history line, the history line is restored to its original state.

`previous-history` (`C-p`)
> Move ‘back’ through the history list, fetching the previous command.

`next-history` (`C-n`)
> Move ‘forward’ through the history list, fetching the next command.

`beginning-of-history` (`M-<`)
> Move to the first line in the history.

`end-of-history` (`M->`)
> Move to the end of the input history, i.e., the line currently being entered.

`reverse-search-history` (`C-r`)
> Search backward starting at the current line and moving ‘up’ through the
> history as necessary. This is an incremental search. This command sets the region
> to the matched text and activates the mark.  The `ESC` and `C-J` characters will
> terminate an incremental search. `C-g` will abort an incremental search and restore
> the original line

`forward-search-history` (`C-s`)
> Search forward starting at the current line and moving ‘down’ through the history
> as necessary. This is an incremental search. This command sets the region to the
> matched text and activates the mark.

`non-incremental-reverse-search-history` (`M-p`)
> Search backward starting at the current line and moving ‘up’ through the history
> as necessary using a non-incremental search for a string supplied by the user. The
> search string may match anywhere in a history line.

`non-incremental-forward-search-history` (`M-n`)
> Search forward starting at the current line and moving ‘down’ through the history as necessary using a non-incremental search for a string supplied by the user. The search string may match anywhere in a history line

`yank-nth-arg` (`M-C-y`)
> Insert the first argument to the previous command (usually the second word on the
> previous line) at point. With an argument n, insert the nth word from the previous
> command (the words in the previous command begin with word 0). A negative argument
> inserts the nth word from the end of the previous command. Once the argument n is
> computed, the argument is extracted as if the ‘!n’ history expansion had been
> specified.

yank-last-arg (`M-.` or `M-_`)
Insert last argument to the previous command (the last word of the previous history
entry). With a numeric argument, behave exactly like yank-nth-arg. Successive calls
to yank-last-arg move back through the history list, inserting the last word (or the
word specified by the argument to the first call) of each line in turn. Any numeric
argument supplied to these successive calls determines the direction to move through
the history. A negative argument switches the direction through the history (back
or forward). The history expansion facilities are used to extract the last argument,
as if the ‘!$’ history expansion had been specified.

`operate-and-get-next` (`C-o`)
> Accept the current line for return to the calling application as if a newline had
> been entered, and fetch the next line relative to the current line from the history
> for editing. A numeric argument, if supplied, specifies the history entry to use
> instead of the current line.


Commands For Changing Text
--------------------------

`end-of-file` (usually `C-d`)
> The character indicating end-of-file as set, for example, by stty. If this character
> is read when there are no characters on the line, and point is at the beginning of
> the line, Readline interprets it as the end of input and returns EOF.

`delete-char` (`C-d`)
> Delete the character at point. If this function is bound to the same character as
> the tty EOF character, as C-d commonly is, see above for the effects.

`backward-delete-char` (`Rubout`)
> Delete the character behind the cursor. A numeric argument means to kill the characters
> instead of deleting them.

`quoted-insert` (`C-q` or `C-v`)
> Add the next character typed to the line verbatim. This is how to insert key sequences
> like C-q, for example.

`tab-insert` (`M-TAB`)
> Insert a tab character.

`transpose-chars` (`C-t`)
> Drag the character before the cursor forward over the character at the cursor, moving
> the cursor forward as well. If the insertion point is at the end of the line, then
> this transposes the last two characters of the line. Negative arguments have no effect.

`transpose-words` (`M-t`)
> Drag the word before point past the word after point, moving point past that word
> as well. If the insertion point is at the end of the line, this transposes the last
> two words on the line.

`upcase-word` (`M-u`)
> Uppercase the current (or following) word. With a negative argument, uppercase the
> previous word, but do not move the cursor.

`downcase-word` (`M-l`)
> Lowercase the current (or following) word. With a negative argument, lowercase the
> previous word, but do not move the cursor.

`capitalize-word` (`M-c`)
> Capitalize the current (or following) word. With a negative argument, capitalize
> the previous word, but do not move the cursor.


Killing And Yanking
-------------------

`kill-line` (`C-k`)
> Kill the text from point to the end of the line. With a negative numeric argument,
> kill backward from the cursor to the beginning of the current line.

`backward-kill-line` (`C-x Rubout`)
> Kill backward from the cursor to the beginning of the current line. With a negative
> numeric argument, kill forward from the cursor to the end of the current line.

`unix-line-discard` (`C-u`)
> Kill backward from the cursor to the beginning of the current line.

`kill-word` (`M-d`)
> Kill from point to the end of the current word, or if between words, to the end of
> the next word. Word boundaries are the same as forward-word.

`backward-kill-word` (`M-DEL`)
> Kill the word behind point. Word boundaries are the same as backward-word.

`shell-transpose-words` (`M-C-t`)
> Drag the word before point past the word after point, moving point past that word
> as well. If the insertion point is at the end of the line, this transposes the
> last two words on the line. Word boundaries are the same as shell-forward-word and
> shell-backward-word.

`unix-word-rubout` (`C-w`)
> Kill the word behind point, using white space as a word boundary. The killed text
> is saved on the kill-ring.

`yank` (`C-y`)
> Yank the top of the kill ring into the buffer at point.

`yank-pop` (`M-y`)
> Rotate the kill-ring, and yank the new top. You can only do this if the prior command
> is yank or yank-pop.

Specifying Numeric Arguments
----------------------------

`digit-argument` (`M-0`, `M-1`, … `M--`)
> Add this digit to the argument already accumulating, or start a new argument. `M--`
> starts a negative argument.


Letting Readline Type For You
-----------------------------

`complete` (`TAB`)
> Attempt to perform completion on the text before point. The actual completion
> performed is application-specific. The default is filename completion.

`possible-completions` (`M-?`)
> List the possible completions of the text before point. When displaying
> completions, Readline sets the number of columns used for display to the value of
> completion-display-width, the value of the environment variable COLUMNS, or the
> screen width, in that order.

`insert-completions` (`M-*`)
> Insert all completions of the text before point that would have been generated by
> possible-completions.


Keyboard Macros
---------------

`start-kbd-macro` (`C-x (`)
> Begin saving the characters typed into the current keyboard macro.

`end-kbd-macro` (`C-x )`)
> Stop saving the characters typed into the current keyboard macro and save the definition.

`call-last-kbd-macro` (`C-x e`)
> Re-execute the last keyboard macro defined, by making the characters in the macro
> appear as if typed at the keyboard.


Some Miscellaneous Commands
---------------------------

`re-read-init-file` (`C-x C-r`)
> Read in the contents of the inputrc file, and incorporate any bindings or variable
> assignments found there.

`abort` (`C-g`)
> Abort the current editing command and ring the terminal’s bell (subject to the
> setting of bell-style).

`do-lowercase-version` (`M-A`, `M-B`, `M-x`, …)
> If the metafied character x is upper case, run the command that is bound to the
> corresponding metafied lower case character. The behavior is undefined if x is
> already lower case.

`prefix-meta` (`ESC`)
> Metafy the next character typed. This is for keyboards without a meta key. Typing
> ‘ESC f’ is equivalent to typing M-f.

`undo` (`C-_` or `C-x C-u`)
> Incremental undo, separately remembered for each line.

`revert-line` (`M-r`)
> Undo all changes made to this line. This is like executing the undo command enough
> times to get back to the beginning.

`tilde-expand` (`M-~`)
> Perform tilde expansion on the current word.

`set-mark` (`C-@`)
> Set the mark to the point. If a numeric argument is supplied, the mark is set to
> that position.

`exchange-point-and-mark` (`C-x C-x`)
> Swap the point with the mark. The current cursor position is set to the saved position,
> and the old cursor position is saved as the mark.

`character-search` (`C-]`)
> A character is read and point is moved to the next occurrence of that character. A
> negative argument searches for previous occurrences.

`character-search-backward` (`M-C-]`)
> A character is read and point is moved to the previous occurrence of that character. A
> negative argument searches for subsequent occurrences.

`insert-comment` (`M-#`)
> Without a numeric argument, the value of the comment-begin variable is inserted at the
> beginning of the current line. If a numeric argument is supplied, this command acts
> as a toggle: if the characters at the beginning of the line do not match the value
> of comment-begin, the value is inserted, otherwise the characters in comment-begin
> are deleted from the beginning of the line. In either case, the line is accepted as
> if a newline had been typed.

`emacs-editing-mode` (`C-e`)
> When in vi command mode, this causes a switch to emacs editing mode.

`vi-editing-mode` (`M-C-j`)
> When in emacs editing mode, this causes a switch to vi editing mode.


Source: <https://tiswww.cwru.edu/php/chet/readline/rluserman.html>
